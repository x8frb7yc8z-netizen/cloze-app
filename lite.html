<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">
<title>极简完形填空 Pro Sync</title>
<style>

/* 加粗单词的样式 */
.word-bold {
    font-weight: 800;
    color: #000;
    /* 可以加个底色或者下划线增加辨识度 */

}
:root { --primary: #43a047; --bg: #f8f9fa; --danger: #ff5252; --input-bg: #fffde7; }
* { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
html, body { margin:0; padding:0; width:100%; min-height:100%; font-family:-apple-system, sans-serif; background:#fff; }

/* 1. 修正容器和导航条 */
.app-container { 
    display: flex; 
    flex-direction: column; 

    padding-top: 35px; /* 略大于导航条高度 */
}
.btn-group { display:flex; align-items:center; gap:8px; }

.main-area { 
    flex: 1; 
    position: relative; 
    overflow-y: auto; 
    -webkit-overflow-scrolling: touch;
}
/* 2. 核心修正：取消绝对定位，改用相对定位 */
#inputText, #clozeContent {
    width: 100%; 
    min-height: calc(100vh - 35px);
    text-align: center;
    padding: 20px 0px; /* 增加顶部间距防止被挡 */
    border: none; 
    outline: none;
    font-size: 20px !important; 
    line-height: 1; 
    font-family: inherit;
    white-space: pre-wrap; 
    word-break: break-word;
    position: relative; /* 改为 relative */
    display: block;
}
/* 2. 只有当屏幕真的很窄（手机竖屏）时才切换 */
@media screen and (max-width: 500px) {
    #inputText, #clozeContent {
        font-size: 26px !important;
    }
}
#inputText { resize: none; }
#clozeContent { display: none; } /* 默认隐藏 */

.exercise-mode #inputText { display: none !important; }
.exercise-mode #clozeContent { display: block !important; }
.exercise-mode .edit-only { display: none; }
.exercise-mode .exercise-only { display: flex !important; flex: 1; }

/* 核心：输入框样式 */
.cloze-display-input {
    font-size: 0.9em; 
    min-width: 2.2ch; 
    height: 1.2em;
    margin: 0 2px;
    border: none; 
    border-bottom: 2px solid #666;
    background: var(--input-bg);
    text-align: center;
    border-radius: 0;
    -webkit-appearance: none; /* 移除 iOS 默认阴影 */
    vertical-align: middle;
}

/* 1. 导航条改为顶部固定 */
.footer-actions { 
    display: flex; 
    background: #fff; 
    position: fixed; 
    top: 0; 
    left: 0; 
    width: 100%; 
    z-index: 1000; /* 确保在最顶层 */
    height: 30px; 
    border-bottom: 1px solid #ddd;
}
/* 2. 按钮文字和间距调整 */
.footer-actions button { 
    flex: 1; 
    padding: 0; /* 移除内边距，让文字垂直居中 */
    border: none; 
    font-weight: bold; 
    cursor: pointer; 
    /* 核心修改：字号稍微缩小一点以配合矮窄的导航条 */
    font-size: 14px; 
    display: flex;
    align-items: center;
    justify-content: center;
}
/* 3. 字体调节区域的高度同步 */
.font-ctrl {
    display: flex;
    align-items: center;
    gap: 5px;
    padding: 0 10px;
    font-size: 14px;
}
.btn-primary { background:var(--primary); color:white; }
.btn-danger { color:var(--danger); background:#fff8f8; }

#clozeContent {
    /* 允许容器内的文本正常响应系统手势 */
    -webkit-user-select: text;
    user-select: text;
    
    /* 解决部分浏览器在滚动中长按失效的问题 */
    pointer-events: auto; 
    
    /* 增加行高，减少手指点击时的误差 */
    line-height: 1.2;
}

.word-span {
    -webkit-user-select: text !important;
    user-select: text !important;
    -webkit-touch-callout: default !important;
    
    /* 关键：去掉 padding 防止坐标偏移 */
    padding: 0 !important;
    margin: 0 !important;
    display: inline; /* 确保它像普通文字一样排列 */
}

.cloze-display-input {
    /* 输入框通常长按会弹出全选/粘贴，保持默认即可 */
    -webkit-user-select: auto;
}
.exercise-only { display: none !important; }
</style>
</head>

<body>
<div class="app-container" id="app">
    <nav class="footer-actions">
        <button class="btn-danger edit-only" onclick="handleClear()">清空</button>
	<button class="exercise-only" onclick="copyFullText()" style="background:#f3e5f5;">复制</button>
	<button id="boldModeBtn" class="exercise-only" onclick="toggleBoldMode()" style="background:#e8f5e9;">加粗: 关</button>
        <div class="font-ctrl edit-only">
             <button class="font-btn" onclick="changeFontSize(-2)">A-</button>
             <span id="fontSizeLabel">26</span>
             <button class="font-btn" onclick="changeFontSize(2)">A+</button>
        </div>
        <button class="btn-primary edit-only" onclick="toggleMode(true)">开始练习</button>
        <button class="btn-primary exercise-only" onclick="toggleMode(false)">← 返回修改</button>
    </nav>

    <main class="main-area">
        <textarea id="inputText" placeholder="在此粘贴文章内容..."></textarea>
        <div id="clozeContent"></div>
    </main>
</div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js";
  import { getDatabase, ref, set, get, child } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-database.js";

  const firebaseConfig = {
    apiKey: "AIzaSyDQwjomxjLURd0nWmS0RuhkaecXISqALzs",
    authDomain: "cloze-master-pro.firebaseapp.com",
    databaseURL: "https://cloze-master-pro-default-rtdb.asia-southeast1.firebasedatabase.app",
    projectId: "cloze-master-pro",
    storageBucket: "cloze-master-pro.firebasestorage.app",
    messagingSenderId: "697808901954",
    appId: "1:697808901954:web:32455d94bf67e522e01adb"
  };

  const fbApp = initializeApp(firebaseConfig);
  const db = getDatabase(fbApp);

  // 获取文档唯一ID
  window.getDocId = function() {
    const urlParams = new URLSearchParams(window.location.search);
    const customId = urlParams.get('customid');
    
    if (customId && customId.trim() !== "") {
        return "cid_" + customId.trim(); 
    }

    const text = inputArea.value.trim();
    if (!text) return null;
    try {
        // 使用文本前25个字符生成Base64指纹作为ID
        return btoa(unescape(encodeURIComponent(text.substring(0, 25)))).replace(/[/+=]/g, "");
    } catch(e) { return "default_doc"; }
  }

  // 获取当前屏幕顶端单词索引（用于阅读进度同步）
  function getTopWordIndex() {
    const offset = 45; 
    const x = window.innerWidth / 2;
    const el = document.elementFromPoint(x, offset);
    
    if (el && el.dataset.index) {
        return parseInt(el.dataset.index);
    }
    return 0;
  }
	
  // 上传同步数据
  window.syncUpload = async function() {
    const id = window.getDocId();
    if (!id) return;
    const topIdx = getTopWordIndex();

    // 仅保存加粗位置、阅读进度和时间戳
    set(ref(db, 'clozes/' + id), { 
        boldPositions: boldPositions, 
        topIndex: topIdx,
        ts: Date.now() 
    });
  };

  // 下载同步数据
  window.syncDownload = async function() {
    const urlParams = new URLSearchParams(window.location.search);
    const hasCustomId = !!urlParams.get('customid');
    const currentInput = document.getElementById('inputText'); 
    
    const id = window.getDocId();
    if (!id || !currentInput) return;

    let snapshot = await get(child(ref(db), 'clozes/' + id));
    
    // 兼容逻辑：如果没有找到 customId 对应的数据，尝试查找旧版 ID
    if (!snapshot.exists() && hasCustomId) {
        const oldTextId = btoa(unescape(encodeURIComponent(currentInput.value.substring(0, 25)))).replace(/[/+=]/g, "");
        snapshot = await get(child(ref(db), 'clozes/' + oldTextId));
    }

    if (snapshot.exists()) {
        const data = snapshot.val();
        
        // --- 核心修正点：移除对已删除变量 manualPositions 的引用 ---
        // 即使数据库里有 positions 数据，我们也只取加粗数据
        boldPositions = data.boldPositions || [];
        
        if (app.classList.contains('exercise-mode')) {
            renderCloze(); 
            
            // 恢复阅读进度锚点
            if (data.topIndex !== undefined) {
                setTimeout(() => {
                    const targetEl = document.querySelector(`[data-index="${data.topIndex}"]`);
                    if (targetEl) {
                        // 滚动到上次的位置
                        targetEl.scrollIntoView({ behavior: 'auto', block: 'start' });
                        window.scrollBy(0, -45); // 补偿导航栏高度
                    }
                }, 600);
            }
        }
    }
  };
</script>
<script>
// 1. 核心状态变量
let currentFontSize = 26;
let boldPositions = [];
let isBoldMode = false; // 已修复：添加初始定义

const app = document.getElementById('app');
const inputArea = document.getElementById('inputText');
const clozeContent = document.getElementById('clozeContent');

// 2. 渲染函数
function renderCloze() {
    const text = inputArea.value;
    if (!text) return;

    // 修复：必须在此处初始化计数器，确保每次重新渲染从0开始
    let unitCount = 0; 
    
    // 匹配单词、中文、标点及空格
    const segments = text.split(/([a-zA-Z]+|[\u4e00-\u9fa5]|[^\s\w\u4e00-\u9fa5]+)/g);
    
    clozeContent.innerHTML = segments.map(seg => {
        if (!seg || !seg.trim()) return seg;
        const idx = unitCount++;
        
        const boldClass = boldPositions.includes(idx) ? 'word-bold' : '';
        return `<span class="word-span ${boldClass}" data-index="${idx}">${seg}</span>`;
    }).join("");
    
    bindEvents();
}

// 3. 事件绑定逻辑
function bindEvents() {
    function getSentenceByPunct(el) {
        if (!el || !el.classList.contains('word-span')) return null;
        const parent = el.parentNode;
        const children = Array.from(parent.querySelectorAll('.word-span, span'));
        const index = children.indexOf(el);
        const boundary = /[.!?。！？；;]/;

        let start = index;
        let end = index;

        while (start > 0 && !boundary.test(children[start - 1].textContent || "")) start--;
        while (end < children.length - 1 && !boundary.test(children[end].textContent || "")) end++;
        if (end < children.length && boundary.test(children[end].textContent || "")) end++;

        const sentenceNodes = children.slice(start, end);
        const sentenceText = sentenceNodes.map(n => n.textContent).join("");

        // 选中反馈
        const range = document.createRange();
        range.setStartBefore(sentenceNodes[0]);
        range.setEndAfter(sentenceNodes[sentenceNodes.length - 1]);
        const sel = window.getSelection();
        sel.removeAllRanges();
        sel.addRange(range);

        return sentenceText.trim();
    }

    // 单击处理
    clozeContent.onclick = (e) => {
        const target = e.target;
        if (!target.classList.contains('word-span')) return;
        if (!app.classList.contains('exercise-mode')) return;

        const idx = parseInt(target.dataset.index);

        if (isBoldMode) {
            // 加粗切换逻辑
            if (boldPositions.includes(idx)) {
                boldPositions = boldPositions.filter(i => i !== idx);
            } else {
                boldPositions.push(idx);
            }
            // 加粗后关闭模式，方便继续阅读
            isBoldMode = false; 
            updateModeButtons(); 
            savePositions(); // 同步到云端
            renderCloze();
        } else {
            // 普通模式：复制单词
            copyToClipboard(target.innerText.trim());
            const range = document.createRange();
            range.selectNodeContents(target);
            const sel = window.getSelection();
            sel.removeAllRanges();
            sel.addRange(range);
        }
    };

    // 双击处理 (整句复制)
    clozeContent.ondblclick = (e) => {
        if (e.target.classList.contains('word-span') && !isBoldMode) {
            e.preventDefault();
            const txt = getSentenceByPunct(e.target);
            if (txt) copyToClipboard(txt);
        }
    };
}

// 4. 功能切换与同步
window.toggleBoldMode = function() {
    isBoldMode = !isBoldMode;
    // 开启加粗模式时清除现有选择，防止干扰
    if (isBoldMode) window.getSelection()?.removeAllRanges();
    updateModeButtons();
};

function updateModeButtons() {
    const bBtn = document.getElementById('boldModeBtn');
    if(bBtn) {
        bBtn.innerText = isBoldMode ? "加粗: 开" : "加粗: 关";
        bBtn.style.backgroundColor = isBoldMode ? "#a5d6a7" : "#fff";
    }
}

async function copyToClipboard(text) {
    if (!text) return;
    try {
        await navigator.clipboard.writeText(text);
    } catch (err) {
        const el = document.createElement('textarea');
        el.value = text;
        document.body.appendChild(el);
        el.select();
        document.execCommand('copy');
        document.body.removeChild(el);
    }
}

// 进度与云端同步
function savePositions() { 
    if (window.syncUpload) window.syncUpload();
}

// 初始加载逻辑
window.onload = async () => {
    const urlParams = new URLSearchParams(window.location.search);
    const textFromAnki = urlParams.get('text');
    if (textFromAnki) inputArea.value = decodeURIComponent(textFromAnki);

    const savedSize = localStorage.getItem('cloze_user_font_size');
    currentFontSize = savedSize ? parseInt(savedSize) : (window.innerWidth < 500 ? 26 : 20);
    applyFontSize(currentFontSize);

    if (inputArea.value.trim()) {
        renderCloze();
        app.classList.add('exercise-mode');
    }
    document.body.classList.add('app-ready');
    setTimeout(() => { if(window.syncDownload) window.syncDownload(); }, 1000);
};

// 工具函数
function applyFontSize(size) {
    inputArea.style.fontSize = clozeContent.style.fontSize = size + "px";
    const label = document.getElementById('fontSizeLabel');
    if(label) label.innerText = size;
}

function changeFontSize(delta) {
    currentFontSize += delta;
    applyFontSize(currentFontSize);
    localStorage.setItem('cloze_user_font_size', currentFontSize);
}

async function toggleMode(isExercise) {
    if (isExercise) {
        if (!inputArea.value.trim()) return alert("请先输入内容");
        renderCloze();
        app.classList.add('exercise-mode');
        window.scrollTo(0, 0);
    } else {
        app.classList.remove('exercise-mode');
    }
}

function handleClear() {
    if(confirm("确定清空吗？")) {
        inputArea.value = "";
        boldPositions = []; // 修复：移除 manualPositions
        savePositions();
        renderCloze();
    }
}

window.copyFullText = function() {
    const fullText = inputArea.value.trim();
    if (!fullText) return;
    copyToClipboard(fullText);
    const btn = event.currentTarget;
    const old = btn.innerText;
    btn.innerText = "已复制 √";
    setTimeout(() => btn.innerText = old, 1000);
};

// 自动同步阅读位置
let scrollTimer;
window.addEventListener('scroll', () => {
    if (!app.classList.contains('exercise-mode')) return;
    clearTimeout(scrollTimer);
    scrollTimer = setTimeout(() => savePositions(), 1000);
});
</script>
</body>
</html>
